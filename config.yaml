# Database configuration
database:
  host: localhost
  port: 3307
  type: mysql # mysql or postgresql
  user: root
  password: ""
  database: ecommerce_db
  max_connections: 100
  idle_connections: 10
  connection_timeout: 30s

# Proxy configuration
proxy:
  host: 0.0.0.0
  port: 3308
  pool_size: 100
  max_connections_per_host: 50
  read_timeout: 30s
  write_timeout: 30s

# Redis configuration (for config store)
redis:
  host: localhost
  port: 6379
  password: ""
  database: 0
  pool_size: 10

# API Server configuration
api:
  host: 0.0.0.0
  port: 8080
  api_key: "sk_dev_changeme"

# Currency conversion configuration
conversion:
  ratio: 1000 # IDR to IDN conversion ratio
  precision: 4
  rounding_strategy: "BANKERS_ROUND" # BANKERS_ROUND, ARITHMETIC_ROUND, or NO_ROUND

# Currency detection strategy (v2.0)
# Determines how the proxy detects whether incoming values are IDR or IDN
detection_strategy:
  # Detection method: AUTO (recommended), EXPLICIT, FIELD_NAME, or VALUE_RANGE
  method: "AUTO"

  # Field name to check for explicit currency specification (used when method=EXPLICIT or AUTO)
  # Your queries should include this field with value "IDR" or "IDN"
  # Example: INSERT INTO orders (total_amount, currency) VALUES (50000000, 'IDR')
  explicit_field: "currency"

  # Value threshold for range-based detection (used when method=VALUE_RANGE or AUTO)
  # Values below this threshold are considered IDN, above are considered IDR
  # Default: 1000000 (1 million)
  threshold_value: 1000000

# Alternative detection strategies (for reference):
#
# Option 1: Explicit only (most reliable, requires app changes)
# detection_strategy:
#   method: "EXPLICIT"
#   explicit_field: "currency"
#
# Option 2: Field name only (works if you use _idn suffix convention)
# detection_strategy:
#   method: "FIELD_NAME"
#
# Option 3: Value range only (less reliable, use as last resort)
# detection_strategy:
#   method: "VALUE_RANGE"
#   threshold_value: 1000000

# TLS/SSL Configuration (v2.0)
# Secure connections for production deployments
tls:
  # Client-facing TLS (app → proxy)
  client:
    enabled: false # Set to true to enable TLS for client connections
    cert_file: "/path/to/certs/server.crt"
    key_file: "/path/to/certs/server.key"
    ca_file: "/path/to/certs/ca.crt" # Optional: for mutual TLS (mTLS)
    skip_verify: false # Set to true only for development!

  # Backend TLS (proxy → MySQL)
  backend:
    enabled: false # Set to true to enable TLS for MySQL connections
    cert_file: "/path/to/certs/client.crt" # Optional: for client cert auth
    key_file: "/path/to/certs/client.key"
    ca_file: "/path/to/certs/mysql-ca.crt"
    server_name: "mysql.example.com" # Expected MySQL server name
    skip_verify: false # Set to true only for development!

# Production TLS Example (commented):
#
# tls:
#   client:
#     enabled: true
#     cert_file: "/etc/transisidb/tls/server.crt"
#     key_file: "/etc/transisidb/tls/server.key"
#     ca_file: "/etc/transisidb/tls/ca.crt"  # For mTLS
#   backend:
#     enabled: true
#     ca_file: "/etc/transisidb/tls/mysql-ca.crt"
#     server_name: "mysql-prod.example.com"

# Read Replica Routing (v2.0)
# Distribute SELECT queries across read replicas for better performance
replica:
  enabled: false # Set to true to enable replica routing
  strategy: "ROUND_ROBIN" # ROUND_ROBIN, RANDOM, or LEAST_CONNECTIONS
  replicas:
    - host: replica1.example.com
      port: 3306
      user: root
      password: ""
      database: ecommerce_db
    # - host: replica2.example.com
    #   port: 3306
    #   user: root
    #   password: ""
    #   database: ecommerce_db

# Production Replica Example (commented):
#
# replica:
#   enabled: true
#   strategy: "ROUND_ROBIN"
#   replicas:
#     - host: mysql-replica-1.prod.example.com
#       port: 3306
#       user: replication_user
#       password: "${REPLICA_PASSWORD}"
#       database: production_db
#     - host: mysql-replica-2.prod.example.com
#       port: 3306
#       user: replication_user
#       password: "${REPLICA_PASSWORD}"
#       database: production_db

# Query Result Caching (v2.1)
# Redis-based caching for SELECT query results
cache:
  enabled: false # Set to true to enable query caching
  redis_addr: "localhost:6379"
  redis_password: ""
  redis_db: 1 # Separate DB from config storage
  default_ttl: "60s" # Default cache TTL
  max_memory: "512MB" # Max Redis memory for cache
  eviction_policy: "allkeys-lru" # LRU eviction when memory full

  # Per-table cache configuration
  table_configs:
    orders:
      enabled: true
      ttl: "30s" # Hot table, lower TTL
    products:
      enabled: true
      ttl: "5m" # Cold table, higher TTL
    # users:
    #   enabled: false  # Disable caching for sensitive data

# Production Cache Example (commented):
#
# cache:
#   enabled: true
#   redis_addr: "redis-cache.prod.internal:6379"
#   redis_password: "${REDIS_CACHE_PASSWORD}"
#   redis_db: 1
#   default_ttl: "2m"
#   max_memory: "2GB"
#   eviction_policy: "allkeys-lru"
#   table_configs:
#     orders:
#       enabled: true
#       ttl: "1m"  # Frequent updates
#     products:
#       enabled: true
#       ttl: "10m"  # Rarely changes
#     analytics:
#       enabled: true
#       ttl: "1h"  # Heavy queries, cache longer

# Backfill worker configuration
backfill:
  enabled: true
  batch_size: 1000
  sleep_interval_ms: 100
  max_cpu_percent: 20
  retry_attempts: 3
  retry_backoff_ms: 500

# Simulation mode configuration
simulation:
  enabled: true
  allowed_ips:
    - "127.0.0.1"
    - "10.0.0.0/8"
    - "192.168.0.0/16"

# Monitoring configuration
monitoring:
  prometheus_enabled: true
  prometheus_port: 9090
  metrics_path: "/metrics"

# Logging configuration
logging:
  level: "DEBUG" # debug, info, warn, error
  format: "json" # json or text
  output: "stdout" # stdout or file path

# Table configuration (can also be loaded from Redis)
tables:
  orders:
    enabled: true
    columns:
      total_amount:
        source_column: "total_amount"
        target_column: "total_amount_idn"
        source_type: "BIGINT"
        target_type: "DECIMAL(19,4)"
        rounding_strategy: "BANKERS_ROUND"
        precision: 4
      shipping_fee:
        source_column: "shipping_fee"
        target_column: "shipping_fee_idn"
        source_type: "INT"
        target_type: "DECIMAL(12,4)"
        rounding_strategy: "BANKERS_ROUND"
        precision: 4

  invoices:
    enabled: true
    columns:
      grand_total:
        source_column: "grand_total"
        target_column: "grand_total_idn"
        source_type: "BIGINT"
        target_type: "DECIMAL(19,4)"
        rounding_strategy: "BANKERS_ROUND"
        precision: 4
